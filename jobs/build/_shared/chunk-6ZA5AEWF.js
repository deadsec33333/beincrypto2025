import{M as L,Pa as R,U as M,V as u,a as l,b as p,c as O,ga as w,p as h,w as y,x as E}from"/jobs/build/_shared/chunk-FJW73GJ6.js";import{k as d}from"/jobs/build/_shared/chunk-OTKXJQRY.js";d();d();var b=class extends p{constructor({callbackSelector:e,cause:r,data:n,extraData:i,sender:c,urls:o}){super(r.shortMessage||"An error occurred while fetching for an offchain result.",{cause:r,metaMessages:[...r.metaMessages||[],r.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(f=>`    ${l(f)}`)],`  Sender: ${c}`,`  Data: ${n}`,`  Callback selector: ${e}`,`  Extra data: ${i}`].flat()});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}},g=class extends p{constructor({result:e,url:r}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${l(r)}`,`Response: ${u(e)}`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}},x=class extends p{constructor({sender:e,to:r}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${r}`,`OffchainLookup sender address: ${e}`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}};d();function A(t,e){if(!y(t))throw new h({address:t});if(!y(e))throw new h({address:e});return t.toLowerCase()===e.toLowerCase()}var K="0x556f1830",v={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function Q(t,{blockNumber:e,blockTag:r,data:n,to:i}){let{args:c}=M({data:n,abi:[v]}),[o,f,a,s,k]=c;try{if(!A(i,o))throw new x({sender:o,to:i});let m=await C({data:a,sender:o,urls:f}),{data:S}=await R(t,{blockNumber:e,blockTag:r,data:E([s,L([{type:"bytes"},{type:"bytes"}],[m,k])]),to:i});return S}catch(m){throw new b({callbackSelector:s,cause:m,data:n,extraData:k,sender:o,urls:f})}}async function C({data:t,sender:e,urls:r}){let n=new Error("An unknown error occurred.");for(let i=0;i<r.length;i++){let c=r[i],o=c.includes("{data}")?"GET":"POST",f=o==="POST"?{data:t,sender:e}:void 0;try{let a=await fetch(c.replace("{sender}",e).replace("{data}",t),{body:JSON.stringify(f),method:o}),s;if(a.headers.get("Content-Type")?.startsWith("application/json")?s=(await a.json()).data:s=await a.text(),!a.ok){n=new w({body:f,details:s?.error?u(s.error):a.statusText,headers:a.headers,status:a.status,url:c});continue}if(!O(s)){n=new g({result:s,url:c});continue}return s}catch(a){n=new w({body:f,details:a.message,url:c})}}throw n}export{K as a,v as b,Q as c,C as d};
